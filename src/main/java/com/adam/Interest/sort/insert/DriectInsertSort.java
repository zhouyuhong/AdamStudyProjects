package com.adam.Interest.sort.insert;

import com.adam.Interest.sort.ArraysIntObject;

/**
 *  直接插入排序------------插入排序
 *
 *	思想要点：
 *		每一次将待排序的数字放入前面已经排好序的数组中的正确位置
 *	前提：
 *		待排序数字参与排序前，已知数组是一个已排好序的数组
 *
 *	
 */
public class DriectInsertSort {
	
	public static void main(String[] args) {

		int[] arr = ArraysIntObject.getObject();
		
		/*
		 * 1.假设数组的第一个就是已知的顺序
		   2.由1可得此时arr[0]就是第一个已知的数字，所以我们就从a + 1 即 1号开始，
		 */
		for(int a = 1; a < arr.length; a++){
			int temp = arr[a];//此时temp就是带排序的数
			
			int b = 0;//定义下标
			/*
			 * 第二次循环，从已知数组的最后一个开始遍历起，由于已知数组已经有序，所以我们就从后开始比较，直到发现
			 * temp比已知数组中的某一个大时，就放在这个目标数字的后面一位，因为已知数组有序，所以在这个目标数字之前的肯定都比temp小
			 * 如果目标数字大于了temp,则让目标数字后移一位，直到找到目标数字小于temp时，此时temp就放在目标数字后面一位
			 * */
			for(b = a - 1; b >= 0; b--){//因为从已知数组的最后一位开始，所以自然要向前遍历
				if(arr[b] > temp){//说明此时目标数字大于temp，则让目标数字向后移动一位，注意，此时并不和temp交换
					arr[b + 1] = arr[b];
				}else{
					break;//如果temp大于了目标数字，则根据已知数组已是有序来看，temp肯定更大于了目标数字之前的数，所以直接跳出循环
				}
			}

			//然后在把temp赋值给arr[b + 1], 至于为什么不是复制给b，是因为最后跳出循环时，比较的是arr[b]与当前元素的大小，当temp大时
			//跳出循环，说明此时temp应该在arr[b]之后，所以为arr[b+1]
			arr[b + 1] = temp;
		}
		
		ArraysIntObject.show(arr);
	}

	
	/*
	 * 此时我们来模拟一下直接插入排序的情况, 假设此时数组为： 33，11，32， 66
	 * 第一次：a = 1, 已知数组arr[0] = 33,  带插入数字temp为arr[1] = 11
	 * 		 然后进入循环for(b = a - 1; b >= 0; b--)，b = 0
	 * 		 从已知数组最后开始向前比较，此时11 < 33   所以把arr[0]移到arr[0 + 1]的位置, b--后为-1
	 * 		 此时原数组：33, 33, 32, 66
	 * 		然后执行b + 1号放入temp
	 * 		此时原数组：11, 33, 32, 66
	 * 第二次：a = 2, 已知数组arr[0] = 11, arr[1] = 33, 带插入数字temp为arr[2] = 32
	 * 		然后进入循环for(b = a - 1; b >= 0; b--)，b = 1
	 * 		从已知数组最后开始向前比较，此时32 < 33 所以把arr[1]移到arr[1 + 1]的位置，b--后为0
	 * 		此时原数组：11, 33, 33, 66
	 * 		继续for(b = a - 1; b >= 0; b--)，b = 0
	 * 		从已知数组最后开始向前比较， 此时32 > 11 所以跳出循环， 不会执行b--了，此时b依旧为0
	 * 		执行b + 1号放入temp
	 * 		此时原数组：11， 32， 33， 66
	 * 第三次： a = 3, 已知数组arr[0] = 11, arr[1] = 32, arr[2] = 33, 带插入数字temp为arr[3] = 66
	 * 		然后进入循环然后进入循环for(b = a - 1; b >= 0; b--)，b = 2
	 * 		从已知数组最后向前开始比较，此时66 > 33，所以跳出循环，不会执行b--了，此时b依旧为2
	 * 		此时原数组：11, 32, 33, 66
	 * 		执行b + 1号放入temp
	 * 		此时原数组：11, 32, 33, 66
	 * 
	 * 
	 * 所以我们可以推理出，如果运气好，每次直接插入的元素都是整个数组中第二大的，那么就只需要比较一次（即移动最后一个数字即可）
	 * 这种理想状态，比较的次数就是n，即第一个循环循环n次，第二个循环循环一次，所以是n
	 * 但是最不理想的状态也很明确，每次的插入元素都是最小的，那么每次都要把整个数组遍历比较一次，所以执行时间：
	 * 第一个循环为n次，第二个循环为n次，所以是n*n次
	 * */
}
