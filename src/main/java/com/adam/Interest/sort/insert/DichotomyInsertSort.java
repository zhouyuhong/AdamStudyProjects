package com.adam.Interest.sort.insert;

import com.adam.Interest.sort.ArraysIntObject;

/**
 * 	二分插入排序------插入排序
 *	
 *	思想要点：
 *	同直接插入排序，待排序数字排序前，已知数组是一个已经被排好序的数组，但是二分插入排序会先进行一次二分查找，这样就可以在插入前首先排除一半的数字
 *	
 *	前提：
 *	已知数组是一个已排好序的数组，因为要考虑二分查找法，我们知道，二分法的前台就是被分数组是一个有序数组
 *
 */
public class DichotomyInsertSort {

	public static void main(String[] args) {
		
		int arr[] = ArraysIntObject.getObject();
		
		//从第一个开始循环
		for(int a = 0; a < arr.length; a++){
			//把当前下标的元素作为temp元素
			int temp = arr[a];
			
			//定义二分需要的left, right, middle三个属性, 用于对已知数组进行二分
			int left = 0;
			int right = a - 1;//由于待排数是arr[a]，那么它之前的就是已知数组，所以数组右边的就是a - 1
			int mid = 0;
			
			//循环对已知数组进行二分
			while(left <= right){//如果左边小于右边，则获取中间的数，然后与待排序数比较大小----二分算法
				mid = (left + right) >> 1;
				if(temp > arr[mid]){//如果待排序数字大于了中间数，则修改left为mid + 1, 注意mid是下标，实际是arr[mid], 不要比成temp > mid了
					left = mid + 1;
				}else{//如果待排序数字小于等于中间数，则把right修改为mid - 1
					right = mid - 1;
				}
			}
			
			//当二分循环完毕之后，此时就得到一个数，这个数必然是比待排序数大，并且是所有大于待排序数中最小的一个，
			//然后此时就从这个数开始，把后面的所有数向后移动一个位置，此时这个数原来的位置, 即left下标的位置就空了，然后就把这个位置放入我们的待排序数
			for(int b = a - 1; b >= left; b--){//此时左边的数字就不是整个数组了，而是我们通过二分挑出的小数组，
				arr[b + 1] = arr[b];
			}
			//做一个判断，如果letf下标的数字不是当前的temp，根据上面的for循环解释，就把这个位置拿来装temp
			if(arr[left] != temp){
				arr[left] = temp;
			}
		}
		
		ArraysIntObject.show(arr);
	}
	
	/*
	 * 这种排序的思想步骤大致同直接插入排序
	 * 只是唯一不同的就是直接插入排序第二个for循环是比较待排序数之前的数组的所有数据，而二分法优先进行一次筛选
	 * 二分筛选后的数字必然是唯一比当前目标大的最小数，即4，5，6，7都比2大，而4就是比目标数2大的所有数中的最小数
	 * 所以二分之后，只需要把这个最小数以及之后的数全部向右移动一个位置，然后最小数原先的位置用来放待排序数即可
	 * 
	 * 如下：
	 * 【22】， 【33】， 【44】， 【55】， 【66】   待排序的是45
	 * 此时先进行循环，然后二分之后，根据45 得到的数据就二分为如下：
	 * 【22】，【33】，【44】      和         【55】，【66】， 并且最小数就是55
	 * 然后从最小数开始，把后面所有的数字向右移动一个空位，即如下：
	 * 【22】，【33】，【44】，【55+】，【55】，【66】， 【55+】就是原来最小数的位置
	 * 最后把原来最小数的位置放进新的待排序数，即如下：
	 * 【22】，【33】，【44】，【45】，【55】，【66】即排列完毕
	 * 
	 * 二分插入排序比直接排序的好处就是它是优先进行二分查找，然后在进行数组后移，用二分法来代替比较，所以实际循环的次数必然比直接排序要少
	 * 
	 * */
}
