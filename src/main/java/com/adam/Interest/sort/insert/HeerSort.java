package com.adam.Interest.sort.insert;

import com.adam.Interest.sort.ArraysIntObject;

/**
 * 	希尔排序------插入排序
 * 	
 * 	思想要点：
 * 	希尔排序的要点就是选择一个增量，通常为待排序数组长度   / 2， 如此时数组长度为10，则增量为5
 * 	然后把原数组进行分组，按照增量的数字分组，即此时增量为5，则把原数组分为5组，排完后按照当前增量继续 / 2来得到新增量， 并且优先选择奇数
 * 	这样一直除下去，直到增量为1，然后最后在把整个数组最后按照直接插入排序的方式排一边，排序即可完成
 *  接着按照下标的差为增量的数字拿出来放入同一个组中，即0号下标与5号下标为一组，1号下标与6号下标为一组，以此类推
 *  此时数组的分组情况如下
 *  a[0]与a[5]，，a[1]与a[6]，，a[2]与a[7]，，a[3]与a[8]，，a[4]与a[9]，
 *  然后这些组分别进行直接插入排序，排序完成之后，继续分组，此时按照上一个增量的一半分，即此时分组为 5 / 2 ，注意取奇数， 即3
 *  
 *  然后同样按照下标差值分组，此时分的组就如下：
 *  a[0]a[3]a[6],,,,,a[1]a[4]a[7],,,,,a[2]a[5]a[8],,,,a[9],由于此时最后一个单了出来，就并入第一个组
 *  a[0]a[3]a[6]a[9],,,,,a[1]a[4]a[7],,,,,a[2]a[5]a[8]
 *  这样继续按照每一个组进行直接插入排序，排序完之后，继续除以2，此时为3 / 2， 由于优先选择奇数，所以不选2，选1
 *  此时按照下标差值为1分组，即每一个元素一组，这时就把整个数组按照直接插入排序再拍一次，最后即可得到顺序
 *  
 *
 */
public class HeerSort {

	public static void main(String[] args) {
int[] arr = ArraysIntObject.getObject();
		
		//得到数组长度，方便计算增量
		int d = arr.length;
		//由于并不知道增量为几，并且增量计算多少次后才为1，所以用一个while循环
		while(true){
			//得到当前循环排序时的增量
			d = d / 2;
			//按照增量分组
			for(int a = 0; a < d; a++){
				//此时把下标差为增量的分成一组，即遍历从0开始，但是增值不为++，而为+d，即可得到增量差的数组
				/**
				 * 以下都是直接插入排序的思想
				 */
				for(int b = a + d; b < arr.length; b += d){
					//此时按照直接插入排序的思维，temp为第二个元素，这里的第二个元素就为a + d
					int temp = arr[b];//待排元素
					int c;
					//此时倒序遍历已知数组，   与直接插入排序一样
					for(c = b - d; c >= 0; c -= d){
						if(arr[c] > temp){
							//让数组改变,即后移，但是不要后移为arr[c + 1] = arr[c],因为我们是以c + d作为下标跨度的
							arr[c + d] = arr[c];
						}else{
							break;
						}
					}
					
					//然后把b - d的位置放入待排元素
					arr[c + d] = temp;
				}
			}
			
			//当增量为1时，跳出while循环
			if(d == 1){
				break;
			}
			
		}
		
		ArraysIntObject.show(arr);
		
	}
	
	
	/*
	 * 我们发现，希尔排序也是在直接插入排序的基础上进行操作的，只是它采用了分布式的思想，将一个数组分成一系列小的数组，分别排序
	 * 然后在合成，比如下面的数组
	 * 【22】，【11】，【42】，【21】，【55】，【66】
	 * 第一次按照增量，为长度/2，等于三
	 * 此时分组为0, 3      1, 4     2, 5
	 * 所以分组数组为
	 * 0:【22】和3:【21】，  1:【11】和4:【55】， 2:【42】和5:【66】
	 * 然后交换位置可以得到数组如下，注意
	 * 0：【21】和3：【22】， 1：【11】和4：【55】， 2：【42】和5：【66】,则此时数组为
	 * 【21】，【11】，【42】，【21】，【55】，【66】
	 * 然后继续增量，此时为3 / 2，由于取基数，则为1，我们说过，当增量为1时，进行整个数组的插入排序，所以此时整个数组拍完之后
	 * 得到的结果就为正确顺序
	 * 【11】，【21】，【22】，【42】，【55】，【66】
	 * 
	 * 
	 * 这里你可能会说，既然希尔最后还是要做一个全部数组的插入排序，那和直接插入有什么区别呢？我们总结过直接排序的优点和缺点，如果处于理想状态下
	 * 即每次之比较一次，那么直接插入排序无疑是三个插入排序中最快的，但是也有不理想的情况，所以希尔排序的作用就是为了防止直接插入排序的不理想状态而做的
	 * 并且每次分组后用插入排序，比较次数必然比直接用插入排序少，虽然之后的增量变小，导致分组的元素增大，但是由于每次都先排了一次序，所以实际比较次数也远远
	 * 小于直接用排序时的比较次数
	 */
}
